# Пояснение: Поля "Информация о продукте"

## Что это такое?

При конвертации XLSX в VEX вы видите два опциональных поля:

```
┌─────────────────────────────────────────────────────┐
│ Информация о продукте (опционально):                │
├─────────────────────────────────────────────────────┤
│ Название продукта: [Например: My Application]      │
│ Версия продукта:   [Например: 1.0.0]              │
│                                                     │
│ Если не указано, информация о продукте будет       │
│ извлечена из файла                                 │
└─────────────────────────────────────────────────────┘
```

---

## Зачем это нужно?

### 1. **Идентификация продукта в VEX документе**

VEX документ CycloneDX содержит секцию `metadata.component`, которая описывает **продукт**, для которого создается VEX:

```json
{
  "metadata": {
    "component": {
      "type": "application",
      "name": "My Backend Service",    // ← Название продукта
      "version": "2.5.3"                // ← Версия продукта
    }
  }
}
```

Эта информация показывает, **к какому продукту относятся уязвимости** в VEX документе.

### 2. **Автоматическое vs Ручное заполнение**

#### Автоматическое (если не указано):

**Сценарий 1: Один проект выбран**
```
Выбрано: "backend-service"
↓
Название продукта: "backend-service"
```

**Сценарий 2: Все проекты (один файл)**
```
В файле 103 проекта
↓
Название продукта: "Multi-Project Analysis (103 projects)"
```

**Сценарий 3: Все проекты (отдельные файлы)**
```
Для каждого проекта свое название:
- backend-service_vex.json → "backend-service"
- frontend-app_vex.json → "frontend-app"
- api-gateway_vex.json → "api-gateway"
```

#### Ручное (если указано):

Вы можете **переопределить** автоматическое название:

**Пример 1: Объединение проектов под одним брендом**
```
Название продукта: "MyCompany Enterprise Suite"
Версия продукта: "3.0.0"

Результат VEX:
{
  "metadata": {
    "component": {
      "name": "MyCompany Enterprise Suite",
      "version": "3.0.0"
    }
  }
}
```

**Пример 2: Уточнение контекста**
```
Выбран проект: "backend-service"
Название продукта: "MyApp Backend (Production)"
Версия продукта: "2.5.3-prod"

Вместо просто "backend-service" получаем более точное описание
```

---

## Когда и как использовать эти поля?

### ✅ Когда НУЖНО заполнять вручную:

#### 1. **Несколько проектов = один продукт**

Если XLSX содержит уязвимости для **нескольких микросервисов**, которые составляют **один продукт**:

```
Проекты в XLSX:
- auth-service
- api-gateway
- user-service
- payment-service

Это все части одного продукта "MyApp"
↓
Название продукта: "MyApp Platform"
Версия продукта: "1.5.0"
```

#### 2. **Маркетинговое vs Техническое название**

```
Техническое имя проекта: "cnc-core-backend-v2"
↓
Маркетинговое название: "CNC Platform"
Версия: "11.8.3"

Для отчетов клиентам удобнее видеть "CNC Platform v11.8.3"
```

#### 3. **Релиз-специфичная версия**

```
Проект: "mobile-app"
↓
Название: "MyApp Mobile (iOS)"
Версия: "2.1.0-beta.3"

Помогает различать iOS/Android релизы или beta/production
```

#### 4. **Compliance и аудит**

Для сертификации (ISO 27001, SOC 2, и т.д.) важно **точное название и версия** продукта:

```
Название: "Healthcare Management System"
Версия: "3.2.1-HIPAA-compliant"

Соответствует названию в сертификатах
```

### ❌ Когда НЕ нужно заполнять:

#### 1. **Один проект = один продукт**

Если вы конвертируете один проект и его название понятно:

```
Проект: "backend-service"
↓
Автоматически: name: "backend-service"

Не нужно менять, если устраивает
```

#### 2. **Внутренний анализ**

Для внутренних целей (не для клиентов/аудита) технические названия удобнее:

```
Оставляем как есть: "cnc-11.8.3-sbom"
```

#### 3. **Экспорт всех проектов отдельно**

При выборе "Все проекты (отдельные файлы в ZIP)" каждый файл **автоматически** получает имя проекта, что обычно оптимально.

---

## Практические примеры

### Пример 1: Стартап с микросервисами

**Ситуация**:
- У вас 5 микросервисов в одном XLSX
- Все они часть одного продукта "TaskMaster"
- Релиз версии 2.0.0

**Действия**:
1. Выбрать "Все проекты (один файл)"
2. Заполнить:
   - Название: `TaskMaster Platform`
   - Версия: `2.0.0`
3. Конвертировать

**Результат**: VEX документ с `metadata.component.name = "TaskMaster Platform"`, содержащий все 5 микросервисов.

**Польза**: Клиентам отправляется один VEX с понятным названием продукта, а не техническими именами микросервисов.

---

### Пример 2: Крупная компания с множеством продуктов

**Ситуация**:
- XLSX содержит 103 проекта из разных команд
- Нужны отдельные VEX для каждого проекта
- Версионирование по проектам

**Действия**:
1. Выбрать "Все проекты (отдельные файлы в ZIP)"
2. **Не заполнять** поля (оставить пустыми)
3. Конвертировать

**Результат**: ZIP с 103 файлами, каждый с названием проекта.

```
my_analysis_all_projects_vex.zip
├── backend-service_vex.json      (name: "backend-service")
├── frontend-app_vex.json         (name: "frontend-app")
├── mobile-ios_vex.json           (name: "mobile-ios")
└── ...
```

**Польза**: Каждая команда получает свой VEX с корректным названием проекта.

---

### Пример 3: Сертификация продукта

**Ситуация**:
- Проект называется технически: `hc-mgmt-sys-v3`
- Для сертификации нужно официальное название
- Конкретная версия для аудита

**Действия**:
1. Выбрать проект `hc-mgmt-sys-v3`
2. Заполнить:
   - Название: `Healthcare Management System`
   - Версия: `3.2.1`
3. Конвертировать

**Результат**: VEX с официальным названием для аудитора.

```json
{
  "metadata": {
    "component": {
      "name": "Healthcare Management System",
      "version": "3.2.1"
    }
  }
}
```

**Польза**: Соответствие документации для сертификации.

---

## Что происходит с полями в metadata?

### Полная структура metadata в VEX:

```json
{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:xxxxx",
  "version": 1,

  "metadata": {
    "timestamp": "2025-11-05T10:00:00Z",

    "tools": {
      "components": [{
        "type": "application",
        "name": "DevSecOps Tools - XLSX to VEX Converter",
        "version": "1.3.0"
      }]
    },

    "component": {              // ← Сюда попадают ваши поля
      "type": "application",
      "name": "YOUR_PRODUCT_NAME",      // ← Название продукта
      "version": "YOUR_PRODUCT_VERSION"  // ← Версия продукта
    }
  },

  "vulnerabilities": [ /* ... */ ]
}
```

### Использование в инструментах:

VEX документы обрабатываются автоматизированными инструментами:

1. **Dependency-Track**: Показывает название продукта в списке проектов
2. **Grype/Syft**: Фильтрует уязвимости по продукту
3. **SBOM/VEX Validators**: Проверяют соответствие версий
4. **Compliance Tools**: Сопоставляют с реестром продуктов

**Корректное название = правильная обработка в инструментах**

---

## Рекомендации

### Для внутреннего использования:
- ✅ Оставляйте пустым (используйте автоматику)
- ✅ Технические названия проектов удобнее

### Для клиентов/партнеров:
- ✅ Заполняйте вручную
- ✅ Используйте маркетинговые названия
- ✅ Указывайте точные версии релизов

### Для аудита/сертификации:
- ✅ **Обязательно** заполняйте
- ✅ Используйте официальные названия из документов
- ✅ Версии должны совпадать с release notes

### Для автоматизации CI/CD:
- ✅ Можно передавать через API параметры
- ✅ Брать из environment variables: `$PRODUCT_NAME`, `$VERSION`

---

## Пример API вызова с параметрами

```bash
# Без параметров (автоматика)
curl -X POST http://localhost:8000/api/xlsx-to-vex/export \
  -F "xlsx_file=@vulnerabilities.xlsx" \
  -o vex.json

# С параметрами (ручное управление)
curl -X POST http://localhost:8000/api/xlsx-to-vex/export \
  -F "xlsx_file=@vulnerabilities.xlsx" \
  -F "product_name=MyApp Platform" \
  -F "product_version=2.5.0" \
  -o vex.json

# С фильтром проекта
curl -X POST http://localhost:8000/api/xlsx-to-vex/export \
  -F "xlsx_file=@vulnerabilities.xlsx" \
  -F "product_name=MyApp Backend" \
  -F "product_version=2.5.0" \
  -F "project_filter=backend-service" \
  -o backend_vex.json
```

---

## FAQ

**Q: Влияет ли название на фильтрацию уязвимостей?**
A: Нет, фильтрация идет по параметру `project_filter`. Название продукта - это только метаданные.

**Q: Можно ли разные версии для разных проектов в одном VEX?**
A: Нет, в `metadata.component` одна версия. Для разных версий делайте отдельные VEX файлы.

**Q: Что если оставить поля пустыми?**
A: Система автоматически определит название:
- Из выбранного проекта (если фильтр)
- Из списка проектов (если все проекты)
- Или использует "SBOM Analysis" по умолчанию

**Q: Можно ли менять название после генерации VEX?**
A: Да, VEX - это JSON файл. Можно отредактировать `metadata.component.name/version` вручную.

---

## Вывод

**Поля "Информация о продукте" нужны для**:

1. ✅ Правильной идентификации продукта в VEX документе
2. ✅ Соответствия требованиям аудита/сертификации
3. ✅ Понятных названий для клиентов и партнеров
4. ✅ Корректной работы инструментов анализа SBOM/VEX

**Заполняйте вручную**, когда:
- Отправляете VEX клиентам
- Проходите аудит/сертификацию
- Объединяете несколько проектов в один продукт
- Нужны маркетинговые названия вместо технических

**Оставляйте пустым**, когда:
- Внутренний анализ
- Технические названия удобнее
- Автоматика работает корректно

---

**Версия:** v1.3.0
**Дата:** 2025-11-05
